T1: The action of changing the balance of an acount is not an atomic action, there are three steps in it: Retrieving the value
Adding one to the value, and storing the value. Because of that the two threads might fetch the value of balance while
its in the middle of an operation, and thus using the wrong value.

T2: The start order of the threads depends on which order the start() method was called. Each start is queued up until the JVM 
can start the threads. Since they are queued, the ordered is preserved.
After calling the start() method, the thread goes into the 'new' state. Once the thread execution actually start, it goes into the 'runnable' state,
at this point, the thread executes. At certain intervals, the program suspends the thread to allow other threads to execute. Threads can also
be suspended for I/O operations and if the thread is waiting for certain events or for a time expiration. The thread terminates once there os no more
code to execute. Once that happens, the thread goes into the 'stopped' state and the application cleans up the structures related to the thread itself.

T5: The advantages of using a synchronized block is that first of all only a certain part of the code will be given the lock
not the entire method. Secondly it also allows methods to be synchronized over different locks, therefore if two methods
can be accessed at the same time by different threads they can be synchronized over different locks.
